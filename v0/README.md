# Export format, version 0

## Overview

This document describes version 0 of the export format for the **kana** application.
This version can be considered the beta format that we used for testing and development.
It is likely that we will shift to something more robust in the future;
nonetheless, we document version 0 here for back-compatibility purposes,
given that we are obliged to support it anyway.

## Layout

The first 8 bytes define an unsigned 64-bit integer in little-endian, specifying the format type.
This is used to denote whether the input data files are embedded (0) or linked (1);
the former is used for export to a standalone file while the latter is used to save the state to the browser's cache.

The next 8 bytes define another unsigned 64-bit integer describing the format version.
This document will only consider version 0.

The next 8 bytes define another unsigned 64-bit integer specifying the size of the blob containing a gzipped JSON with the analysis parameters and results. 
Let's call this value `state_nbytes`.

The next `state_nbytes` bytes contain a gzipped JSON string.
When unzipped and parsed, it will create a single object that contains one property per step in the analysis.
Each value is itself a dictionary with `parameters` (a dictionary of parameters) and `contents` (the contents, usually the results).
See the next section for details on the expected fields.

The remaining bytes contain the embedded input files when the format type is "embedded".
Each file can be excised by reading the offsets and sizes in the `inputs` field.

## JSON structure

### Comments

`TypedArray`s are represented as objects with the `_TypedArray_class` and `_TypedArray_values` properties.
The former specifies the `TypedArray` subclass (e.g., `Int32Array`) while the latter contains the contents of the `TypedArray` as double-precision values in a normal array.
This is necessary to enable serialization into some reasonably interpretable JSON.

In many cases, readers may observe some duplication of information between the various fields.
This is intended to reduce the dependencies between steps when the state is unserialized,
so as to avoid expensive recalculations throughout the entire analysis pipeline when **kana** requests particular pieces of information.

### Property `inputs`

`parameters` will contain:

- `type`: a string specifying the input file format.
  This is currently either `"MatrixMarket"`, for a MatrixMarket file (with possible feature annotations);
  `"10X"`, for the 10X Genomics HDF5 matrix format;
  or `"H5AD"`, for the H5AD format.
- `files`: an array of objects specifying the position of each file in the remaining bytes section.
  Each object contains:
  - `type`: a string specifying the type of the file.
    This may be `"mtx"`, `"genes"` or `"annotation"` for the MatrixMarket file, feature information and barcode annotations, respectively, when `format = "MatrixMarket"`,
    otherwise it should be `h5`.
  - `name`: a string specifying the file name as it was provided to **kana**.
  - `buffer`: an object containing `offset` and `size`.
    `offset` specifies where the file starts as an offset from the start of the remaining bytes section,
    while `size` specifies the number of bytes in the file.

`contents` will contain:

- `num_cells`: The number of cells in the dataset.
- `genes`: Object containing the provided gene annotations.
  Each key contains the annotation name (e.g., `"ID"`, `"symbol"`) while each value is an array (usually of strings) containing the annotation value for each gene.
  Note that these annotations do not include those generated by the application, only those that were supplied as input by the user.
- (optional) `annotations`: Object containing the provided cell annotations.
  Each key contains the annotation name (e.g., `"cluster"`, `"label"`) while each value is an array containing the annotation value for each cell.
  Note that these annotations do not include those generated by the application, only those that were supplied as input by the user.

### Property `quality_control_metrics`

`parameters` will contain:

- `use_mito_default`: boolean specifying whether to use the default mitochondrial gene list.
- `mito_prefix`: prefix to use to search for mitochondrial gene symbols.

`contents` will contain:

- `sums`: A `Float64Array` of length equal to the number of cells, containing the total count for each cell.
- `detected`:  An `Int32Array` of length equal to the number of cells, containing the total number of detected genes for each cell.
- `proportion`: A `Float64Array` of length equal to the number of cells, containing the percentage of counts in (mitochondrial) genes.

### Property `quality_control_thresholds`

`parameters` will contain:

- `nmads`: number of MADs to use to define the filter thresholds for each metric.

`contents` will contain:

- `sums`: number specifying the threshold for the total count.
- `detected`: number specifying the threshold for the total number of detected genes.
- `proportion`: number specifying the threshold for the mitochondrial proportion.
- `discards`: a `Uint8Array` of length equal to the number of cells, specifying whether each cell would be discarded by the filter thresholds.

### Property `quality_control_filtered`

`parameters` is empty.

`contents` will contain:

- `retained`: the number of cells remaining after filtering.

### Property `normalization`

`parameters` is empty.

`contents` is empty.

### Property `feature_selection`

`parameters` will contain:

- `span`: number specifying the span to use for the LOWESS smoother.

`contents` will contain:

- `means`: a `Float64Array` containing the mean log-expression of each gene.
- `vars`: a `Float64Array` containing the variance in log-expression of each gene.
- `fitted`: a `Float64Array` containing the fitted value of the trend for each gene.
- `resids`: a `Float64Array` containing the residuals from the trend for each gene.

### Property `pca`

`parameters` will contain:

- `num_hvgs`: number of highly variable genes to use to compute the PCA.
- `num_pcs`: number of PCs to compute.

`contents` will contain:

- `pcs`: a `Float64Array` in a column-major layout where the PCs are rows and cells are columns.
- `var_exp`: a `Float64Array` of length equal to the number of PCs, containing the percentage of variance explained by each PC.

### Property `neighbor_index`

`parameters` will contain:

- `approximate`: boolean specifying whether an approximate nearest neighbor search should be performed.

`contents` is empty.

### Property `tsne`

`parameters` will contain:

- `perplexity`: number specifying the t-SNE perplexity.
- `iterations`: number specifying the t-SNE iterations.
- `animate`: boolean indicating whether an animation should be performed.

`contents` will contain:

- `x`: `Float64Array` containing the x-coordinates for each cell.
- `y`: `Float64Array` containing the y-coordinates for each cell.
- `iterations`: number specifying the number of iterations that were performed.
  This is always the same as `iterations` in the `parameters`.

### Property `umap`

`parameters` will contain:

- `num_epochs`: number of epochs to perform.
- `num_neighbors`: number of nearest neighbors to use when constructing the sets.
- `min_dist`: number specifying the minimum distance between points.
- `animate`: boolean indicating whether an animation should be performed.

`contents` will contain:

- `x`: `Float64Array` containing the x-coordinates for each cell.
- `y`: `Float64Array` containing the y-coordinates for each cell.
- `iterations`: number specifying the number of epochs that were performed.
  This is always the same as `num_epochs` in the `parameters`.

### Property `kmeans_cluster` (optional)

`parameters` will contain:

- `k`: number of clusters to create.

`contents` will contain:

- `clusters`: an `Int32Array` containing the cluster assignment for each cell.

Note that `contents` may also be `null` if k-means clustering was not used in the analysis.

### Property `snn_find_neighbors`

`parameters` will contain:

- `k`: number of nearest neighbors to find.

If SNN graph clustering was used in the analysis, `contents` will be empty.
Otherwise, it is `null`.

### Property `snn_build_graph`

`parameters` will contain:

- `scheme`: string specifying the edge weighting scheme to use, based on the ranks (0), number (1) or Jaccard index (2) of the shared neighbors.

If SNN graph clustering was used in the analysis, `contents` will be empty.
Otherwise, it is `null`.

### Property `snn_cluster_graph`

`parameters` will contain:

- `resolution`: number specifying the resolution of the multi-level community detection.

`contents` will contain:

- `clusters`: an `Int32Array` containing the cluster assignment for each cell.

Note that `contents` may also be `null` if SNN graph clustering was not used in the analysis.

### Property `choose_clustering`

`parameters` will contain:

- `method`: string specifying the clustering method to use, either `snn_graph` or `kmeans`.

`contents` is empty.

### Property `marker_detection`

`parameters` is empty.

`contents` is an array of length equal to the number of clusters.
Each element is an object corresponding to a cluster, and contains:

- `means`: a `Float64Array` containing the mean expression of each gene in the cluster.
- `detected`: a `Float64Array` containing the proportion of cells with detected expression of each gene in the cluster.
- `lfc`: an object containing `min`, `mean` and `min-rank`, each of which are `Float64Array`s of length equal to the number of genes.
  These contain the minimum, mean and minimum-rank, respectively, of the log-fold changes from all pairwise comparisons against this cluster for each gene.
- `delta_detected`: same as `lfc`, but for the delta-detected (i.e., difference in the percentage of detected expression).
- `cohen`: same as `lfc`, but for Cohen's d.
- `auc`: same as `lfc`, but for the AUCs.

### Property `custom_marker_management`

`parameters` will contain:

- `selections`: an object defining the custom selections.
  Each key defines the selection name.
  Each value is a `Uint8Array` of length equal to the number of cells, defining which cells are considered to be part of the selection.

`contents` will contain:

- `results`: an object containing the marker results for each selection against all other cells.
  Each value is an object containing:
  - `means`: a `Float64Array` containing the mean expression of each gene in the selection.
  - `detected`: a `Float64Array` containing the proportion of cells with detected expression of each gene in the selection.
  - `lfc`: an object containing `min`, `mean` and `min-rank`, each of which are `Float64Array`s of length equal to the number of genes.
     All arrays contain the same values and are repeated mostly for consistency with the `marker_detection` format.
  - `delta_detected`: same as `lfc`, but for the delta-detected (i.e., difference in the percentage of detected expression).
  - `cohen`: same as `lfc`, but for Cohen's d.
  - `auc`: same as `lfc`, but for the AUCs.

## Remaining bytes

This is a literal concatenation of all input files, so it is usually best if users supply compressed content.
**kana** will not perform any compression on its own.
